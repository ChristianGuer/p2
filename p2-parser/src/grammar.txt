program        → var_decl* func_decl* EOF

type           → 'int' | 'bool' | 'void'

var_decl       → type ID ('[' INTLIT ']')? ';'          // arrays are 1-D

func_decl      → 'def' type ID '(' params? ')' block
params         → param (',' param)*
param          → type ID

block          → '{' var_decl* stmt* '}'

stmt           → assignment ';'
               | func_call ';'
               | 'if' '(' expr ')' block ('else' block)?
               | 'while' '(' expr ')' block
               | 'return' ';'
               | 'return' expr ';'
               | 'break' ';'
               | 'continue' ';'

assignment     → location '=' expr
location       → ID ('[' expr ']')?                     // nums[i], x

func_call      → ID '(' args? ')'
args           → expr (',' expr)*

/* Expression precedence (highest → lowest), all left-associative */

expr           → or_expr
or_expr        → and_expr        ('||' and_expr)*
and_expr       → eq_expr         ('&&' eq_expr)*
eq_expr        → rel_expr        (('==' | '!=') rel_expr)*
rel_expr       → add_expr        (('<' | '<=' | '>' | '>=') add_expr)*
add_expr       → mul_expr        (('+' | '-') mul_expr)*
mul_expr       → unary           (('*' | '/' | '%') unary)*
unary          → ('!' | '-') unary | primary
primary        → literal
               | location
               | func_call
               | '(' expr ')'

literal        → INTLIT | BOOLLIT | STRINGLIT
BOOLLIT        → 'true' | 'false'





/**
 * @file p2-parser.c
 * @brief Compiler phase 2: parser
 */

#include "p2-parser.h"
ASTNode *parse_program(TokenQueue *input);
ASTNode *parse_vardecl(TokenQueue *input);
DecafType parse_type(TokenQueue *input);
ASTNode *parse_conditional(TokenQueue *input);
ASTNode *parse_expression(TokenQueue *input);
ASTNode *parse_block(TokenQueue *input);
void parse_id(TokenQueue *input, char *buffer);

/*
 * helper functions
 */

/**
 * @brief Look up the source line of the next token in the queue.
 *
 * @param input Token queue to examine
 * @returns Source line
 */
int get_next_token_line(TokenQueue *input)
{
  if (TokenQueue_is_empty(input))
  {
    Error_throw_printf("Unexpected end of input\n");
  }
  return TokenQueue_peek(input)->line;
}

/**
 * @brief Check next token for a particular type and text and discard it
 *
 * Throws an error if there are no more tokens or if the next token in the
 * queue does not match the given type or text.
 *
 * @param input Token queue to modify
 * @param type Expected type of next token
 * @param text Expected text of next token
 */
void match_and_discard_next_token(TokenQueue *input, TokenType type,
                                  const char *text)
{
  if (TokenQueue_is_empty(input))
  {
    Error_throw_printf("Unexpected end of input (expected \'%s\')\n", text);
  }
  Token *token = TokenQueue_remove(input);
  if (token->type != type || !token_str_eq(token->text, text))
  {
    Error_throw_printf("Expected \'%s\' but found '%s' on line %d\n", text,
                       token->text, get_next_token_line(input));
  }
  Token_free(token);
}

/**
 * @brief Remove next token from the queue
 *
 * Throws an error if there are no more tokens.
 *
 * @param input Token queue to modify
 */
void discard_next_token(TokenQueue *input)
{
  if (TokenQueue_is_empty(input))
  {
    Error_throw_printf("Unexpected end of input\n");
  }
  Token_free(TokenQueue_remove(input));
}

/**
 * @brief Look ahead at the type of the next token
 *
 * @param input Token queue to examine
 * @param type Expected type of next token
 * @returns True if the next token is of the expected type, false if not
 */
bool check_next_token_type(TokenQueue *input, TokenType type)
{
  if (TokenQueue_is_empty(input))
  {
    return false;
  }
  Token *token = TokenQueue_peek(input);
  return (token->type == type);
}

/**
 * @brief Look ahead at the type and text of the next token
 *
 * @param input Token queue to examine
 * @param type Expected type of next token
 * @param text Expected text of next token
 * @returns True if the next token is of the expected type and text, false if
 * not
 */
bool check_next_token(TokenQueue *input, TokenType type, const char *text)
{
  if (TokenQueue_is_empty(input))
  {
    return false;
  }
  Token *token = TokenQueue_peek(input);
  return (token->type == type) && (token_str_eq(token->text, text));
}

/**
 * @brief Parse and return a Decaf type
 *
 * @param input Token queue to modify
 * @returns Parsed type (it is also removed from the queue)
 */
DecafType parse_type(TokenQueue *input)
{
  if (TokenQueue_is_empty(input))
  {
    Error_throw_printf("Unexpected end of input (expected type)\n");
  }
  Token *token = TokenQueue_remove(input);
  if (token->type != KEY)
  {
    Error_throw_printf("Invalid type '%s' on line %d\n", token->text,
                       get_next_token_line(input));
  }
  DecafType t = VOID;
  if (token_str_eq("int", token->text))
  {
    t = INT;
  }
  else if (token_str_eq("bool", token->text))
  {
    t = BOOL;
  }
  else if (token_str_eq("void", token->text))
  {
    t = VOID;
  }
  else
  {
    Error_throw_printf("Invalid type '%s' on line %d\n", token->text,
                       get_next_token_line(input));
  }
  Token_free(token);
  return t;
}

/**
 * @brief Parse and return a Decaf identifier
 *
 * @param input Token queue to modify
 * @param buffer String buffer for parsed identifier (should be at least
 * @c MAX_TOKEN_LEN characters long)
 */
void parse_id(TokenQueue *input, char *buffer)
{
  if (TokenQueue_is_empty(input))
  {
    Error_throw_printf("Unexpected end of input (expected identifier)\n");
  }
  Token *token = TokenQueue_remove(input);
  if (token->type != ID)
  {
    Error_throw_printf("Invalid ID '%s' on line %d\n", token->text,
                       get_next_token_line(input));
  }
  snprintf(buffer, MAX_ID_LEN, "%s", token->text);
  Token_free(token);
}

/*
 * node-level parsing functions
 */
ASTNode *parse_vardecl(TokenQueue *input)
{
  //get var line number
  int line = TokenQueue_peek(input)->line;
  //get var type
  DecafType tokenType = parse_type(input);
  char name[MAX_TOKEN_LEN];
  parse_id(input, name);
  if (check_next_token(input, SYM, "["))
  {
    // array decleration
    TokenQueue_remove(input);
    Token *peek = TokenQueue_peek(input);
    int array_length;
    if (peek->type == DECLIT)
    {
      array_length = atoi(TokenQueue_remove(input)->text);
    }
    else if (check_next_token_type(input, HEXLIT))
    {
      array_length = strtol(TokenQueue_remove(input)->text, NULL, 16);
    }
    match_and_discard_next_token(input, SYM, "]");
    match_and_discard_next_token(input, SYM, ";");
    return VarDeclNode_new(name, tokenType, true, array_length, line);
  }

  match_and_discard_next_token(input, SYM, ";");
  return VarDeclNode_new(name, tokenType, false, 1, line);
}

ASTNode *breakout_helper(TokenQueue *input)
{
  int line = TokenQueue_peek(input)->line;
  Token *keyword = TokenQueue_peek(input);
  if (!strcmp(keyword->text, "continue"))
  {
    discard_next_token(input);
    match_and_discard_next_token(input, SYM, ";");
    return ContinueNode_new(line);
  }
  else if (!strcmp(keyword->text, "break"))
  {
    discard_next_token(input);
    match_and_discard_next_token(input, SYM, ";");
    return BreakNode_new(line);
  }
  else if (!strcmp(keyword->text, "return"))
  {
    discard_next_token(input);
    if (check_next_token(input, SYM, ";"))
    {
      TokenQueue_remove(input);
      return ReturnNode_new(NULL, line);
    }
    else
    {
      ASTNode *ret = parse_expression(input);
      printf("expecting ;\n");
      match_and_discard_next_token(input, SYM, ";");
      return ReturnNode_new(ret, line);
    }
  }
  return NULL;
}

ASTNode *parse_assignment(TokenQueue *input)
{
  // parse id
  int line = TokenQueue_peek(input)->line;
  char name[MAX_TOKEN_LEN];
  parse_id(input, name);
  ASTNode *left = LocationNode_new(name, NULL, line);

  // parse =
  match_and_discard_next_token(input, SYM, "=");

  // parse value
  ASTNode *value;
  value = parse_expression(input);
  match_and_discard_next_token(input, SYM, ";");
  return AssignmentNode_new(left, value, line);
}

// Helper returns ASTNode representation of bool, int, variable.
ASTNode *type_helper(TokenQueue *input)
{
  Token *peek = TokenQueue_peek(input);
  printf("text helper: %s\n", peek->text);
  printf("Type helper: %d\n", peek->type);
  int line = peek->line;
  char name[MAX_TOKEN_LEN];
  int value;

  if (peek->type == ID)
  {
    parse_id(input, name);
    return LocationNode_new(name, NULL, line);
  }
  else if (peek->type == DECLIT)
  {
    value = atoi(TokenQueue_remove(input)->text);
    return LiteralNode_new_int(value, line);
  }
  else if (check_next_token_type(input, HEXLIT))
  {
    value = strtol(TokenQueue_remove(input)->text, NULL, 16);
    return LiteralNode_new_int(value, line);
  }
  else if (check_next_token(input, KEY, "true") || check_next_token(input, KEY, "false"))
  {
    TokenQueue_remove(input);
    return LiteralNode_new_bool(strcmp(peek->text, "false"), line);
  }
  else if (check_next_token_type(input, STRLIT))
  {
    // Remove leading and trailing quotes
    char *strLit = TokenQueue_remove(input)->text;
    size_t len = strlen(strLit) - 2;
    char *parsed_str = malloc(len + 1);
    strncpy(parsed_str, strLit + 1, len);
    parsed_str[len] = '\0';

    ASTNode *str = LiteralNode_new_string(parsed_str, line);
    free(parsed_str);
    return str;
  }
  return NULL;
}

BinaryOpType op_type_helper(TokenQueue *input)
{
  char value[MAX_TOKEN_LEN];
  strncpy(value, TokenQueue_peek(input)->text, MAX_TOKEN_LEN - 1);

  if (!strcmp(value, "||"))
  {
    return OROP;
  }
  if (!strcmp(value, "&&"))
  {
    return ANDOP;
  }
  if (!strcmp(value, "=="))
  {
    return EQOP;
  }
  if (!strcmp(value, "!="))
  {
    return NEQOP;
  }
  if (!strcmp(value, "<"))
  {
    return LEOP;
  }
  if (!strcmp(value, "<="))
  {
    return LEOP;
  }
  if (!strcmp(value, ">="))
  {
    return GEOP;
  }
  if (!strcmp(value, ">"))
  {
    return GTOP;
  }
  if (!strcmp(value, "+"))
  {
    return ADDOP;
  }
  if (!strcmp(value, "-"))
  {
    return SUBOP;
  }
  if (!strcmp(value, "*"))
  {
    return MULOP;
  }
  if (!strcmp(value, "/"))
  {
    return DIVOP;
  }
  if (!strcmp(value, "%"))
  {
    return MODOP;
  }
  return 13;
}

ASTNode *parse_while(TokenQueue *input)
{
  int line = TokenQueue_peek(input)->line;
  match_and_discard_next_token(input, KEY, "while");
  match_and_discard_next_token(input, SYM, "(");
  ASTNode *expression = parse_expression(input);
  match_and_discard_next_token(input, SYM, ")");
  ASTNode *block = parse_block(input);
  return WhileLoopNode_new(expression, block, line);
}

/*
ASTNode *parse_expression(TokenQueue *input)
{
  // TODO this will need to be redone for Left associativity
  // TODO add functionality for parethesis
  // TODO add function call compatibility
  int line = TokenQueue_peek(input)->line;
  Token *peek;
  // check for !(op) case: need to add function call compatibility later
  if (check_next_token(input, SYM, "!"))
  {
    TokenQueue_remove(input);
    if (check_next_token(input, SYM, "!"))
    {
      Error_throw_printf("Multiple binary operations");
    }
    ASTNode *expression = parse_expression(input);
    return UnaryOpNode_new(NOTOP, expression, line);
  }
  else
  {
    // left side of 
    //if we need left associativy, then we need to loop here

    ASTNode *left = type_helper(input);

    // Get binary operator from helper
    BinaryOpType operator = op_type_helper(input);
    if (operator > 12)
    {
      // Next token not operator
      return left;
    }
    TokenQueue_remove(input);

    ASTNode *right = type_helper(input);
    return BinaryOpNode_new(operator, left, right, line);
  }
  return NULL;
}
*/

//MY EXPERIMENTAL CODE with left associativity and precedence annd no ambiguity
/* ========= unary: '!' | '-' | primary ========= */
// unary → ('!' | '-') primary | primary
/* ========= primary: literal | location | call | (expr) ========= */
/* ========= Helpers for calls/locations/args ========= */
static NodeList* parse_arglist(TokenQueue* in) {
  NodeList* args = NodeList_new();
  if (!check_next_token(in, SYM, ")")) {
    while (true) {
      ASTNode* e = parse_expression(in);
      NodeList_add(args, e);
      if (check_next_token(in, SYM, ",")) {
        match_and_discard_next_token(in, SYM, ",");
      } else break;
    }
  }
  return args;
}
static ASTNode* parse_location_after_id(Token* idTok, TokenQueue* in) {
  char name[MAX_ID_LEN];
  snprintf(name, sizeof(name), "%s", idTok->text);
  int line = idTok->line;

  ASTNode* index = NULL;
  if (check_next_token(in, SYM, "[")) {
    match_and_discard_next_token(in, SYM, "[");
    index = parse_expression(in);           // full expr as index
    match_and_discard_next_token(in, SYM, "]");
  }
  return LocationNode_new(name, index, line);
}

static ASTNode* parse_primary(TokenQueue* in) {
  if (TokenQueue_is_empty(in))
    Error_throw_printf("Unexpected end of input (expected expression)\n");

  Token* t = TokenQueue_peek(in);

  /* ( expr ) */
  if (check_next_token(in, SYM, "(")) {
    match_and_discard_next_token(in, SYM, "(");
    ASTNode* e = parse_expression(in);
    match_and_discard_next_token(in, SYM, ")");
    return e;
  }

  /* literals */
  if (t->type == DECLIT) {
    Token* tok = TokenQueue_remove(in);
    int v = atoi(tok->text);
    ASTNode* n = LiteralNode_new_int(v, tok->line);
    Token_free(tok);
    return n;
  }
  if (t->type == HEXLIT) {
    Token* tok = TokenQueue_remove(in);
    int v = (int)strtol(tok->text, NULL, 16);
    ASTNode* n = LiteralNode_new_int(v, tok->line);
    Token_free(tok);
    return n;
  }
  if (t->type == STRLIT) {
    Token* tok = TokenQueue_remove(in);
    size_t len = strlen(tok->text);
    char* s = (char*)malloc(len - 1);          /* strip quotes */
    memcpy(s, tok->text + 1, len - 2);
    s[len - 2] = '\0';
    ASTNode* n = LiteralNode_new_string(s, tok->line);
    free(s);
    Token_free(tok);
    return n;
  }
  if (check_next_token(in, KEY, "true") || check_next_token(in, KEY, "false")) {
    Token* tok = TokenQueue_remove(in);
    bool v = !token_str_eq(tok->text, "false");
    ASTNode* n = LiteralNode_new_bool(v, tok->line);
    Token_free(tok);
    return n;
  }

  /* ID → func_call | location */
  if (t->type == ID) {
    Token* idTok = TokenQueue_remove(in);

    if (check_next_token(in, SYM, "(")) {
      match_and_discard_next_token(in, SYM, "(");
      NodeList* args = parse_arglist(in);
      match_and_discard_next_token(in, SYM, ")");
      ASTNode* call = FuncCallNode_new(idTok->text, args, idTok->line);
      Token_free(idTok);
      return call;
    }

    ASTNode* loc = parse_location_after_id(idTok, in);
    Token_free(idTok);
    return loc;
  }

  Error_throw_printf("Invalid expression starting with '%s' on line %d\n",
                     t->text, t->line);
  return NULL;
}



static ASTNode* parse_unary(TokenQueue* in) {
  if (check_next_token(in, SYM, "!") || check_next_token(in, SYM, "-")) {
    Token* op = TokenQueue_remove(in);              // get the operator, keep its line
    // Forbid chaining like "!!x", "--x", "!-x" (immediate second unary)
    if (check_next_token(in, SYM, "!") || check_next_token(in, SYM, "-")) {
      int line = op->line;
      Token_free(op);
      Error_throw_printf("Consecutive unary operators are not allowed on line %d\n", line);
    }

    // Exactly one unary, then a primary (so "-(a+b)" and "!(x<y)" are fine)
    ASTNode* child = parse_primary(in);

    UnaryOpType u = token_str_eq(op->text, "!") ? NOTOP : NEGOP;
    int line = op->line;
    Token_free(op);
    return UnaryOpNode_new(u, child, line);
  }

  return parse_primary(in);
}



/* ========= rel: add (('<'|'<='|'>'|'>=') add)* ========= */
/* ========= mul: unary (('*'|'/'|'%') unary)* ========= */
static ASTNode* parse_mul(TokenQueue* input) {
  ASTNode* left = parse_unary(input);
  while (check_next_token(input, SYM, "*") ||
         check_next_token(input, SYM, "/") ||
         check_next_token(input, SYM, "%")) {
    BinaryOpType op_type = op_type_helper(input);
    Token* op = TokenQueue_remove(input);
    ASTNode* right = parse_unary(input);
    left = BinaryOpNode_new(op_type, left, right, op->line);
    Token_free(op);
  }
  return left;
}

/* ========= add: mul (('+'|'-') mul)* ========= */
static ASTNode* parse_add(TokenQueue* input) {
  ASTNode* left = parse_mul(input);
  while (check_next_token(input, SYM, "+") ||
         check_next_token(input, SYM, "-")) {
    BinaryOpType op_type = op_type_helper(input);
    Token* op = TokenQueue_remove(input);
    ASTNode* right = parse_mul(input);
    left = BinaryOpNode_new(op_type, left, right, op->line);
    Token_free(op);
  }
  return left;
}


static ASTNode* parse_rel(TokenQueue* input) {
  ASTNode* left = parse_add(input);
  while (check_next_token(input, SYM, "<")  ||
         check_next_token(input, SYM, "<=") ||
         check_next_token(input, SYM, ">")  ||
         check_next_token(input, SYM, ">=")) {
    BinaryOpType op_type = op_type_helper(input);
    Token* op = TokenQueue_remove(input);
    ASTNode* right = parse_add(input);
    left = BinaryOpNode_new(op_type, left, right, op->line);
    Token_free(op);
  }
  return left;
}

/* ========= eq: rel (('=='|'!=') rel)* ========= */
ASTNode* parse_eq(TokenQueue* input) {
  ASTNode* left = parse_rel(input);
  while (check_next_token(input, SYM, "==") ||
         check_next_token(input, SYM, "!=")) {
    BinaryOpType op_type = op_type_helper(input);
    Token* op = TokenQueue_remove(input);
    ASTNode* right = parse_rel(input);
    left = BinaryOpNode_new(op_type, left, right, op->line);
    Token_free(op);
  }
  return left;
}

ASTNode *parse_and(TokenQueue *input){
  ASTNode *left = parse_eq(input);
  while (check_next_token(input, SYM, "&&")) {
    BinaryOpType op_type = op_type_helper(input);    
    Token* op = TokenQueue_remove(input);
    ASTNode* right = parse_eq(input);
    left = BinaryOpNode_new(op_type, left, right, op->line);
    Token_free(op);
  }
  return left;
}

ASTNode *parse_or(TokenQueue *input){
  //int line = TokenQueue_peek(input)->line;
  ASTNode *left = parse_and(input);
  while(check_next_token(input, SYM, "||")){
    BinaryOpType op_type = op_type_helper(input);    
    Token *op = TokenQueue_remove(input);
    ASTNode *right = parse_and(input);
    left = BinaryOpNode_new(op_type, left, right, op->line);
    Token_free(op);
  }
  return left;
}

ASTNode *parse_expression(TokenQueue *input){
  return parse_or(input);
}

//END HERE
ASTNode *parse_statement(TokenQueue *input)
{
  Token *next = TokenQueue_peek(input);
  TokenQueue_print(input, stdout);
  ASTNode *current;
  if (next->type == ID)
  {
    // handle assignment and function call
    current = parse_assignment(input);
  }
  else
  {
    if (check_next_token(input, KEY, "if"))
    {
      current = parse_conditional(input);
    }
    else if (check_next_token(input, KEY, "while"))
    {
      current = parse_while(input);
    }
    else
    {
      // else should be a breakout statement throw error if not
      current = breakout_helper(input);
      if (current == NULL)
      {
        Error_throw_printf("Invalid statement on line %d", get_next_token_line(input));
      }
    }
  }
  return current;
}


ASTNode *parse_block(TokenQueue *input)
{
  //TODO: add stsmt before expressions. stmt-> expr
  // match brackets
  int line = TokenQueue_peek(input)->line;
  match_and_discard_next_token(input, SYM, "{");

  // Loop for variable declarations
  Token *next = TokenQueue_peek(input);
  NodeList *vars = NodeList_new();
  NodeList *stmts = NodeList_new();
  while (strcmp(next->text, "int") == 0 || strcmp(next->text, "bool") == 0)
  {
    ASTNode *vardecl = parse_vardecl(input);
    NodeList_add(vars, vardecl);
    next = TokenQueue_peek(input);
  }
  
  //START STMTS new code
  while( !check_next_token(input, SYM, "}") )
  {
    // Loop for assignments TODO modify to accept every statement
    ASTNode *statment = parse_statement(input);
    NodeList_add(stmts, statment);
    next = TokenQueue_peek(input);
  }
  //END

  // match brackets and return
  match_and_discard_next_token(input, SYM, "}");
  return BlockNode_new(vars, stmts, line);
}

ASTNode *parse_conditional(TokenQueue *input)
{
  int line = TokenQueue_peek(input)->line;
  match_and_discard_next_token(input, KEY, "if");
  match_and_discard_next_token(input, SYM, "(");
  ASTNode *expression = parse_expression(input);
  match_and_discard_next_token(input, SYM, ")");
  ASTNode *block = parse_block(input);
  if (check_next_token(input, KEY, "else"))
  {
    ASTNode *else_block = parse_block(input);
    return ConditionalNode_new(expression, block, else_block, line);
  }
  else
  {
    return ConditionalNode_new(expression, block, NULL, line);
  }
}

ParameterList *param_helper(TokenQueue *input)
{
  Token *peek = TokenQueue_peek(input);
  ParameterList *pl = ParameterList_new();
  char name[MAX_TOKEN_LEN];
  DecafType type;
  while (!strcmp(peek->text, "int") || !strcmp(peek->text, "bool"))
  {

    type = parse_type(input);
    parse_id(input, name);
    ParameterList_add_new(pl, name, type);

    if (check_next_token(input, SYM, ","))
    {
      match_and_discard_next_token(input, SYM, ",");
      peek = TokenQueue_peek(input);
      if (strcmp(peek->text, "int") && strcmp(peek->text, "bool"))
      {
        Error_throw_printf("Invalid parameters");
      }
    }
    else
    {
      break;
    }
    peek = TokenQueue_peek(input);
  }
  return pl;
}

ASTNode *parse_function_decl(TokenQueue *input)
{
  //get LineNumber
  int line = TokenQueue_peek(input)->line;
  // preconfirmed def and remove token
  match_and_discard_next_token(input, KEY, "def");
  // Return type
  DecafType returnType = parse_type(input);
  // Identifier
  char name[MAX_TOKEN_LEN];
  parse_id(input, name);

  // Parse parantheses and Squiggle brackets
  match_and_discard_next_token(input, SYM, "(");
  ParameterList *parameters = param_helper(input);
  match_and_discard_next_token(input, SYM, ")");
  ASTNode *block = parse_block(input);
  return FuncDeclNode_new(name, returnType, parameters, block, line);
}

ASTNode *parse_program(TokenQueue *input)
{
  NodeList *vars = NodeList_new();
  NodeList *funcs = NodeList_new();

  while (!TokenQueue_is_empty(input))
  {
    Token *next = TokenQueue_peek(input);

    if (next == NULL)
    {
      break;
    }

    if (check_next_token(input, KEY, "def"))
    {
      // function def
      ASTNode *func_decl = parse_function_decl(input);
      NodeList_add(funcs, func_decl);
    }
    else
    {
      // variable dec
      ASTNode *vardecl = parse_vardecl(input);
      NodeList_add(vars, vardecl);
    }
  }

  return ProgramNode_new(vars, funcs);
}

ASTNode *parse(TokenQueue *input) { 
  //TokenQueue_print(input, stdout);
  return parse_program(input); }
